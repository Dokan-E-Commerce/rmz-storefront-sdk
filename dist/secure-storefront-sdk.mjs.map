{"version":3,"sources":["../src/core/environment.ts","../src/core/security.ts","../src/core/http-client.ts","../src/secure-storefront-sdk.ts"],"sourcesContent":["/**\n * Environment Detection and Configuration\n * Secure environment handling for client/server-side compatibility\n */\n\nexport interface EnvironmentInfo {\n  isServer: boolean;\n  isBrowser: boolean;\n  isWebWorker: boolean;\n  isNode: boolean;\n  platform: 'browser' | 'node' | 'webworker' | 'unknown';\n}\n\nexport class Environment {\n  private static _info: EnvironmentInfo | null = null;\n\n  static get info(): EnvironmentInfo {\n    if (!this._info) {\n      this._info = this.detect();\n    }\n    return this._info;\n  }\n\n  private static detect(): EnvironmentInfo {\n    // Server-side detection (Node.js)\n    const isNode = typeof process !== 'undefined' && \n                   process.versions && \n                   process.versions.node;\n\n    // Browser detection\n    const isBrowser = typeof globalThis !== 'undefined' && \n                      typeof (globalThis as any).window !== 'undefined' && \n                      typeof (globalThis as any).window.document !== 'undefined';\n\n    // Web Worker detection\n    const isWebWorker = typeof (globalThis as any).importScripts === 'function' && \n                        typeof (globalThis as any).navigator !== 'undefined';\n\n    // Server-side is anything that's not browser or web worker\n    const isServer = !isBrowser && !isWebWorker;\n\n    let platform: 'browser' | 'node' | 'webworker' | 'unknown' = 'unknown';\n    if (isNode) platform = 'node';\n    else if (isBrowser) platform = 'browser';\n    else if (isWebWorker) platform = 'webworker';\n\n    return {\n      isServer,\n      isBrowser,\n      isWebWorker,\n      isNode: !!isNode,\n      platform\n    };\n  }\n\n  /**\n   * Get environment variables securely\n   * Only works server-side for security\n   */\n  static getEnvVar(key: string): string | undefined {\n    if (!this.info.isServer) {\n      console.warn(`Environment variable access attempted in ${this.info.platform} environment. Use configuration object instead.`);\n      return undefined;\n    }\n\n    // Node.js environment\n    if (typeof process !== 'undefined' && process.env) {\n      return process.env[key];\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Check if we can use secure features\n   */\n  static canUseSecureFeatures(): boolean {\n    return this.info.isServer || (this.info.isBrowser && \n      typeof (globalThis as any).window !== 'undefined' && \n      (globalThis as any).window.isSecureContext);\n  }\n\n  /**\n   * Get secure crypto implementation\n   */\n  static getCrypto(): any {\n    if (this.info.isServer && typeof require !== 'undefined') {\n      try {\n        return require('crypto');\n      } catch {\n        return null;\n      }\n    }\n\n    if (this.info.isBrowser && \n        typeof (globalThis as any).window !== 'undefined' && \n        (globalThis as any).window.crypto && \n        (globalThis as any).window.crypto.subtle) {\n      return (globalThis as any).window.crypto;\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if fetch is available\n   */\n  static hasFetch(): boolean {\n    return typeof fetch !== 'undefined';\n  }\n\n  /**\n   * Get appropriate HTTP client\n   */\n  static getHttpClient(): any {\n    if (this.hasFetch()) {\n      return fetch;\n    }\n\n    // Fallback for Node.js environments without fetch\n    if (this.info.isServer) {\n      try {\n        // Try to use node-fetch if available\n        return require('node-fetch');\n      } catch {\n        try {\n          // Try to use axios if available\n          return require('axios');\n        } catch {\n          throw new Error('No HTTP client available. Please install node-fetch or axios for Node.js environments.');\n        }\n      }\n    }\n\n    throw new Error('No HTTP client available');\n  }\n}","/**\n * Security Module - HMAC Authentication & Data Protection\n * Framework-agnostic security implementation\n */\n\nimport { Environment } from './environment';\n\nexport interface SecurityConfig {\n  publicKey: string;\n  secretKey?: string; // Only for server-side\n  signatureVersion: string;\n  timestampTolerance: number;\n  authToken?: string; // Bearer token for authenticated requests\n  cartToken?: string; // Cart token for session management\n}\n\nexport class SecurityManager {\n  private config: SecurityConfig;\n\n  constructor(config: SecurityConfig) {\n    this.config = {\n      ...config,\n      signatureVersion: config.signatureVersion || 'v1',\n      timestampTolerance: config.timestampTolerance || 300 // 5 minutes\n    };\n\n    // Validate security requirements\n    this.validateConfig();\n  }\n\n  /**\n   * Set authentication token for authenticated requests\n   */\n  setAuthToken(token: string | null): void {\n    this.config.authToken = token || undefined;\n  }\n\n  /**\n   * Get current authentication token\n   */\n  getAuthToken(): string | undefined {\n    return this.config.authToken;\n  }\n\n  /**\n   * Set cart token for session management\n   */\n  setCartToken(token: string | null): void {\n    this.config.cartToken = token || undefined;\n  }\n\n  /**\n   * Get current cart token\n   */\n  getCartToken(): string | undefined {\n    return this.config.cartToken;\n  }\n\n  private validateConfig(): void {\n    if (!this.config.publicKey) {\n      throw new Error('Public key is required');\n    }\n\n    // Server-side requires secret key for HMAC\n    if (Environment.info.isServer && !this.config.secretKey) {\n      throw new Error('Secret key is required for server-side operations');\n    }\n\n    // Client-side should not have secret key\n    if (Environment.info.isBrowser && this.config.secretKey) {\n      console.warn('Secret key detected in browser environment. This is a security risk!');\n    }\n  }\n\n  /**\n   * Generate HMAC signature (server-side only)\n   */\n  async generateSignature(\n    timestamp: string,\n    method: string,\n    path: string,\n    body: string = ''\n  ): Promise<string> {\n    if (!Environment.info.isServer) {\n      throw new Error('Signature generation is only available server-side');\n    }\n\n    if (!this.config.secretKey) {\n      throw new Error('Secret key required for signature generation');\n    }\n\n    const crypto = Environment.getCrypto();\n    if (!crypto) {\n      throw new Error('Crypto module not available');\n    }\n\n    // Create payload for signing\n    const payload = [\n      this.config.signatureVersion,\n      timestamp,\n      method.toUpperCase(),\n      path,\n      this.hashString(body, crypto)\n    ].join('\\n');\n\n    // Generate HMAC signature\n    const hmac = crypto.createHmac('sha256', this.config.secretKey);\n    hmac.update(payload);\n    return hmac.digest('hex');\n  }\n\n  /**\n   * Verify HMAC signature (server-side only)\n   */\n  async verifySignature(\n    signature: string,\n    timestamp: string,\n    method: string,\n    path: string,\n    body: string = ''\n  ): Promise<boolean> {\n    if (!Environment.info.isServer) {\n      throw new Error('Signature verification is only available server-side');\n    }\n\n    // Check timestamp validity\n    const now = Math.floor(Date.now() / 1000);\n    const requestTime = parseInt(timestamp);\n    \n    if (Math.abs(now - requestTime) > this.config.timestampTolerance) {\n      return false;\n    }\n\n    try {\n      const expectedSignature = await this.generateSignature(timestamp, method, path, body);\n      return this.constantTimeCompare(signature, expectedSignature);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get authentication headers for requests\n   */\n  getAuthHeaders(method: string, path: string, body: string = ''): Record<string, string> {\n    const timestamp = Math.floor(Date.now() / 1000).toString();\n    \n    const headers: Record<string, string> = {\n      'X-Public-Key': this.config.publicKey,\n      'X-Timestamp': timestamp,\n      'X-Signature-Version': this.config.signatureVersion\n    };\n\n    // Add Bearer token for authenticated requests\n    if (this.config.authToken) {\n      headers['Authorization'] = `Bearer ${this.config.authToken}`;\n      console.log('DEBUG: Adding Authorization header:', `Bearer ${this.config.authToken.substring(0, 20)}...`);\n    } else {\n      console.log('DEBUG: No auth token available, skipping Authorization header');\n    }\n\n    // Add cart token for session management\n    if (this.config.cartToken) {\n      headers['X-Cart-Token'] = this.config.cartToken;\n      console.log('DEBUG: Adding cart token header:', this.config.cartToken.substring(0, 10) + '...');\n    }\n\n    // Add signature for both server-side and client-side requests if secret key is available\n    if (this.config.secretKey) {\n      try {\n        if (Environment.info.isServer) {\n          // For server-side, use synchronous generation\n          const signature = this.generateSignatureSync(timestamp, method, path, body);\n          headers['X-Signature'] = signature;\n        } else if (Environment.info.isBrowser) {\n          // For browser, use async Web Crypto API\n          // We'll generate this synchronously using a crypto library for browser\n          const signature = this.generateBrowserSignature(timestamp, method, path, body);\n          headers['X-Signature'] = signature;\n        }\n      } catch (error) {\n        console.warn('Failed to generate signature:', error);\n        headers['X-Client-Auth'] = 'true';\n      }\n    } else {\n      // No secret key available, use client auth header\n      headers['X-Client-Auth'] = 'true';\n    }\n\n    return headers;\n  }\n\n  /**\n   * Synchronous signature generation for Node.js\n   */\n  private generateSignatureSync(\n    timestamp: string,\n    method: string,\n    path: string,\n    body: string = ''\n  ): string {\n    if (!Environment.info.isServer || !this.config.secretKey) {\n      throw new Error('Synchronous signature generation requires server environment and secret key');\n    }\n\n    const crypto = Environment.getCrypto();\n    if (!crypto) {\n      throw new Error('Crypto module not available');\n    }\n\n    const payload = [\n      this.config.signatureVersion,\n      timestamp,\n      method.toUpperCase(),\n      path,\n      crypto.createHash('sha256').update(body).digest('hex')\n    ].join('\\n');\n\n    return crypto.createHmac('sha256', this.config.secretKey).update(payload).digest('hex');\n  }\n\n  /**\n   * Hash string with SHA-256\n   */\n  private hashString(input: string, crypto: any): string {\n    if (Environment.info.isServer) {\n      return crypto.createHash('sha256').update(input).digest('hex');\n    } else {\n      // For browser environment, we need to use Web Crypto API\n      // This is a simplified implementation\n      return input; // In real implementation, use Web Crypto API\n    }\n  }\n\n  /**\n   * Generate HMAC signature for browser environments\n   * Uses a synchronous approach that mimics the server implementation\n   */\n  private generateBrowserSignature(\n    timestamp: string,\n    method: string,\n    path: string,\n    body: string = ''\n  ): string {\n    if (!this.config.secretKey) {\n      throw new Error('Secret key required for signature generation');\n    }\n\n    // Use the same logic as server-side\n    const bodyHash = this.sha256(body);\n    const payload = [\n      this.config.signatureVersion,\n      timestamp,\n      method.toUpperCase(),\n      path,\n      bodyHash\n    ].join('\\n');\n\n    // Generate HMAC using the same method as server\n    return this.hmacSha256(payload, this.config.secretKey);\n  }\n\n  /**\n   * SHA-256 hash implementation compatible with server\n   */\n  private sha256(data: string): string {\n    // For empty string, return the standard SHA-256 hash\n    if (!data) {\n      return 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';\n    }\n\n    // Use crypto-js library approach\n    return require('crypto-js/sha256')(data).toString();\n  }\n\n  /**\n   * HMAC-SHA256 implementation compatible with server\n   */\n  private hmacSha256(data: string, key: string): string {\n    const CryptoJS = require('crypto-js');\n    return CryptoJS.HmacSHA256(data, key).toString();\n  }\n\n  /**\n   * Constant-time string comparison to prevent timing attacks\n   */\n  private constantTimeCompare(a: string, b: string): boolean {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    let result = 0;\n    for (let i = 0; i < a.length; i++) {\n      result |= a.charCodeAt(i) ^ b.charCodeAt(i);\n    }\n\n    return result === 0;\n  }\n\n  /**\n   * Sanitize data for client-side exposure\n   */\n  sanitizeClientData(data: any): any {\n    if (Array.isArray(data)) {\n      return data.map(item => this.sanitizeClientData(item));\n    }\n\n    if (data && typeof data === 'object') {\n      const sanitized: any = {};\n      const sensitiveFields = [\n        'password', 'secret', 'key', 'token', 'api_key', \n        'private_key', 'secret_key', 'webhook_secret',\n        'email_verified_at', 'remember_token', 'deleted_at',\n        'created_by', 'updated_by', 'deleted_by'\n      ];\n\n      // Allow specific legitimate tokens that are needed by the client\n      const allowedTokens = [\n        'session_token', 'csrf_token', 'access_token', 'refresh_token', 'token'\n      ];\n\n      for (const [key, value] of Object.entries(data)) {\n        const keyLower = key.toLowerCase();\n        \n        // Check if this is an allowed token\n        const isAllowedToken = allowedTokens.some(allowedToken => \n          keyLower === allowedToken\n        );\n        \n        const isSensitive = !isAllowedToken && sensitiveFields.some(field => \n          keyLower.includes(field) || keyLower.endsWith('_secret') || keyLower.endsWith('_token')\n        );\n\n        if (!isSensitive) {\n          sanitized[key] = this.sanitizeClientData(value);\n        } else {\n          // Debug: Log what's being filtered out\n          console.log(`🚫 SecurityManager: Filtering out sensitive field: ${key} (isAllowedToken: ${isAllowedToken})`);\n        }\n      }\n\n      return sanitized;\n    }\n\n    return data;\n  }\n\n  /**\n   * Generate secure random string\n   */\n  generateSecureRandom(length: number = 32): string {\n    const crypto = Environment.getCrypto();\n    \n    if (Environment.info.isServer && crypto) {\n      return crypto.randomBytes(length).toString('hex');\n    } else if (Environment.info.isBrowser && crypto && crypto.getRandomValues) {\n      const array = new Uint8Array(length);\n      crypto.getRandomValues(array);\n      return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n    }\n\n    // Fallback (less secure)\n    console.warn('Using fallback random generation - not cryptographically secure');\n    return Math.random().toString(36).substring(2) + Date.now().toString(36);\n  }\n\n  /**\n   * Validate API response integrity\n   */\n  validateResponse(response: any): boolean {\n    // Basic validation - ensure response has expected structure\n    if (!response || typeof response !== 'object') {\n      return false;\n    }\n\n    // Check for success indicator\n    if (typeof response.success !== 'boolean') {\n      return false;\n    }\n\n    // Validate data structure if present\n    if (response.data !== undefined && response.data !== null) {\n      // Sanitize data for client-side\n      response.data = this.sanitizeClientData(response.data);\n    }\n\n    return true;\n  }\n}","/**\n * Universal HTTP Client - Framework Agnostic\n * Works in Browser, Node.js, Web Workers, and any JavaScript environment\n */\n\nimport { Environment } from './environment';\nimport { SecurityManager } from './security';\n\nexport interface HttpConfig {\n  baseUrl: string;\n  timeout: number;\n  maxRetries: number;\n  retryDelay: number;\n  headers: Record<string, string>;\n}\n\nexport interface HttpRequest {\n  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS';\n  url: string;\n  data?: any;\n  headers?: Record<string, string>;\n  timeout?: number;\n}\n\nexport interface HttpResponse<T = any> {\n  data: T;\n  status: number;\n  statusText: string;\n  headers: Record<string, string>;\n}\n\nexport class UniversalHttpClient {\n  private config: HttpConfig;\n  private security: SecurityManager;\n\n  constructor(config: Partial<HttpConfig>, security: SecurityManager) {\n    this.config = {\n      timeout: 30000,\n      maxRetries: 3,\n      retryDelay: 1000,\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n      },\n      ...config,\n      baseUrl: config.baseUrl || ''\n    };\n    this.security = security;\n  }\n\n  /**\n   * Make HTTP request with automatic retry and security headers\n   */\n  async request<T = any>(request: HttpRequest): Promise<HttpResponse<T>> {\n    const url = this.buildUrl(request.url);\n    const body = request.data ? JSON.stringify(request.data) : '';\n    \n    // Get security headers\n    const authHeaders = this.security.getAuthHeaders(\n      request.method,\n      new URL(url).pathname,\n      body\n    );\n\n    // Merge headers\n    const headers = {\n      ...this.config.headers,\n      ...authHeaders,\n      ...request.headers\n    };\n\n    // Add User-Agent for Node.js\n    if (Environment.info.isNode) {\n      headers['User-Agent'] = `StorefrontSDK/1.0 (${Environment.info.platform})`;\n    }\n\n    let lastError: Error;\n\n    // Retry logic\n    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {\n      try {\n        const response = await this.makeRequest({\n          ...request,\n          url,\n          headers\n        }, body);\n\n        // Validate response security\n        if (!this.security.validateResponse(response.data)) {\n          throw new Error('Invalid response format');\n        }\n\n        return response as HttpResponse<T>;\n      } catch (error) {\n        lastError = error as Error;\n        \n        // Don't retry on certain errors\n        if (this.shouldNotRetry(error as Error) || attempt === this.config.maxRetries) {\n          break;\n        }\n\n        // Wait before retry\n        await this.delay(this.config.retryDelay * Math.pow(2, attempt));\n      }\n    }\n\n    throw lastError!;\n  }\n\n  /**\n   * Make the actual HTTP request based on environment\n   */\n  private async makeRequest<T>(request: HttpRequest & { url: string }, body: string): Promise<HttpResponse<T>> {\n    const timeout = request.timeout || this.config.timeout;\n\n    if (Environment.info.isBrowser || Environment.hasFetch()) {\n      return this.fetchRequest(request, body, timeout);\n    } else if (Environment.info.isNode) {\n      return this.nodeRequest(request, body, timeout);\n    } else {\n      throw new Error('No HTTP client available for this environment');\n    }\n  }\n\n  /**\n   * Fetch-based request (Browser/Node.js with fetch)\n   */\n  private async fetchRequest<T>(request: HttpRequest & { url: string }, body: string, timeout: number): Promise<HttpResponse<T>> {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n      const fetchOptions: RequestInit = {\n        method: request.method,\n        headers: request.headers,\n        signal: controller.signal\n      };\n\n      if (request.method !== 'GET') {\n        fetchOptions.body = body;\n      }\n\n      const response = await fetch(request.url, fetchOptions);\n      clearTimeout(timeoutId);\n\n      const responseData = await this.parseResponse(response);\n\n      return {\n        data: responseData,\n        status: response.status,\n        statusText: response.statusText,\n        headers: this.extractHeaders(response.headers)\n      };\n    } catch (error) {\n      clearTimeout(timeoutId);\n      throw this.normalizeError(error);\n    }\n  }\n\n  /**\n   * Node.js request (fallback for environments without fetch)\n   */\n  private async nodeRequest<T>(request: HttpRequest & { url: string }, body: string, timeout: number): Promise<HttpResponse<T>> {\n    // Try to use available Node.js HTTP client\n    const httpClient = Environment.getHttpClient();\n    \n    if (httpClient.default) {\n      // Using axios\n      const axios = httpClient.default;\n      try {\n        const response = await axios({\n          method: request.method,\n          url: request.url,\n          data: request.method !== 'GET' ? JSON.parse(body || '{}') : undefined,\n          headers: request.headers,\n          timeout\n        });\n\n        return {\n          data: response.data,\n          status: response.status,\n          statusText: response.statusText,\n          headers: response.headers\n        };\n      } catch (error: any) {\n        throw this.normalizeError(error);\n      }\n    } else {\n      // Using node-fetch or similar\n      return this.fetchRequest(request, body, timeout);\n    }\n  }\n\n  /**\n   * Parse response based on content type\n   */\n  private async parseResponse(response: Response): Promise<any> {\n    const contentType = response.headers.get('content-type') || '';\n\n    if (contentType.includes('application/json')) {\n      return response.json();\n    } else if (contentType.includes('text/')) {\n      return response.text();\n    } else {\n      return response.blob();\n    }\n  }\n\n  /**\n   * Extract headers from response\n   */\n  private extractHeaders(headers: Headers | Record<string, string>): Record<string, string> {\n    const result: Record<string, string> = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach((value, key) => {\n        result[key] = value;\n      });\n    } else {\n      Object.assign(result, headers);\n    }\n\n    return result;\n  }\n\n  /**\n   * Build full URL\n   */\n  private buildUrl(path: string): string {\n    if (path.startsWith('http://') || path.startsWith('https://')) {\n      return path;\n    }\n\n    const baseUrl = this.config.baseUrl.replace(/\\/$/, '');\n    const cleanPath = path.startsWith('/') ? path : `/${path}`;\n    \n    return `${baseUrl}${cleanPath}`;\n  }\n\n  /**\n   * Check if error should not be retried\n   */\n  private shouldNotRetry(error: Error): boolean {\n    // Don't retry on client errors (4xx) except 429 (rate limit)\n    if (error.message.includes('4')) {\n      return !error.message.includes('429');\n    }\n\n    // Don't retry on certain network errors\n    const nonRetryableErrors = ['ENOTFOUND', 'ECONNREFUSED', 'CERT_'];\n    return nonRetryableErrors.some(err => error.message.includes(err));\n  }\n\n  /**\n   * Normalize errors across different HTTP clients\n   */\n  private normalizeError(error: any): Error {\n    if (error.response) {\n      // Axios-style error\n      return new Error(`HTTP ${error.response.status}: ${error.response.statusText}`);\n    } else if (error.status) {\n      // Fetch-style error\n      return new Error(`HTTP ${error.status}: ${error.statusText}`);\n    } else {\n      // Network or other error\n      return error instanceof Error ? error : new Error(String(error));\n    }\n  }\n\n  /**\n   * Delay utility for retries\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Convenience methods\n  async get<T = any>(url: string, params?: Record<string, any>, headers?: Record<string, string>): Promise<HttpResponse<T>> {\n    let requestUrl = url;\n    \n    if (params && Object.keys(params).length > 0) {\n      const searchParams = new URLSearchParams();\n      \n      for (const [key, value] of Object.entries(params)) {\n        if (value !== undefined && value !== null && value !== '') {\n          searchParams.append(key, String(value));\n        }\n      }\n      \n      const queryString = searchParams.toString();\n      if (queryString) {\n        requestUrl += (url.includes('?') ? '&' : '?') + queryString;\n      }\n    }\n    \n    return this.request<T>({ method: 'GET', url: requestUrl, headers });\n  }\n\n  async post<T = any>(url: string, data?: any, headers?: Record<string, string>): Promise<HttpResponse<T>> {\n    return this.request<T>({ method: 'POST', url, data, headers });\n  }\n\n  async put<T = any>(url: string, data?: any, headers?: Record<string, string>): Promise<HttpResponse<T>> {\n    return this.request<T>({ method: 'PUT', url, data, headers });\n  }\n\n  async patch<T = any>(url: string, data?: any, headers?: Record<string, string>): Promise<HttpResponse<T>> {\n    return this.request<T>({ method: 'PATCH', url, data, headers });\n  }\n\n  async delete<T = any>(url: string, headers?: Record<string, string>): Promise<HttpResponse<T>> {\n    return this.request<T>({ method: 'DELETE', url, headers });\n  }\n}","/**\n * Secure Storefront SDK - Framework Agnostic\n * Works with any JavaScript framework: React, Vue, Angular, Svelte, Vanilla JS\n * Supports both client-side and server-side environments\n */\n\nimport { Environment } from './core/environment';\nimport { SecurityManager } from './core/security';\nimport { UniversalHttpClient } from './core/http-client';\n\nexport interface StorefrontConfig {\n  apiUrl: string;\n  publicKey: string;\n  secretKey?: string; // Only for server-side\n  environment?: 'production' | 'development';\n  version?: string;\n  timeout?: number;\n  maxRetries?: number;\n  retryDelay?: number;\n  enableLogging?: boolean;\n}\n\nexport interface ApiResponse<T = any> {\n  success: boolean;\n  data: T;\n  message?: string;\n  pagination?: {\n    current_page: number;\n    last_page: number;\n    per_page: number;\n    total: number;\n    has_more_pages: boolean;\n  };\n}\n\nexport interface Product {\n  id: number;\n  name: string;\n  slug: string;\n  description?: string;\n  price: number;\n  image?: {\n    url: string;\n    alt?: string;\n  };\n  category?: Category;\n  is_featured?: boolean;\n  stock?: number;\n}\n\nexport interface Category {\n  id: number;\n  name: string;\n  slug: string;\n  description?: string;\n  image?: string;\n}\n\nexport interface Cart {\n  items: CartItem[];\n  count: number;\n  subtotal: number;\n  total: number;\n  currency: string;\n}\n\nexport interface CartItem {\n  id: number;\n  product_id: number;\n  product: Product;\n  quantity: number;\n  price: number;\n  total: number;\n}\n\nexport interface Store {\n  id: number;\n  name: string;\n  description?: string;\n  logo?: string;\n  currency: string;\n  settings?: Record<string, any>;\n}\n\nexport interface Customer {\n  id: number;\n  firstName: string;\n  lastName: string;\n  email: string;\n  phone?: string;\n}\n\nexport interface Order {\n  id: number;\n  status: string;\n  items: OrderItem[];\n  total: number;\n  created_at: string;\n}\n\nexport interface OrderItem {\n  id: number;\n  product: Product;\n  quantity: number;\n  price: number;\n}\n\nexport interface Review {\n  id: number;\n  rating: number;\n  comment: string;\n  reviewer: {\n    id: number;\n    name: string;\n    email?: string;\n  } | null;\n  product?: {\n    id: number;\n    name: string;\n    slug: string;\n  } | null;\n  created_at: string;\n}\n\n/**\n * Main Storefront SDK Class\n * Framework-agnostic with client/server-side support\n */\nexport class SecureStorefrontSDK {\n  private config: StorefrontConfig & {\n    environment: 'production' | 'development';\n    version: string;\n    timeout: number;\n    maxRetries: number;\n    retryDelay: number;\n    enableLogging: boolean;\n  };\n  private security: SecurityManager;\n  private http: UniversalHttpClient;\n  private static instances: Map<string, SecureStorefrontSDK> = new Map();\n\n  constructor(config: StorefrontConfig) {\n    this.config = {\n      environment: 'production',\n      version: '1.0.0',\n      timeout: 30000,\n      maxRetries: 3,\n      retryDelay: 1000,\n      enableLogging: false,\n      ...config\n    };\n\n    // Initialize security manager\n    this.security = new SecurityManager({\n      publicKey: this.config.publicKey,\n      secretKey: this.config.secretKey,\n      signatureVersion: 'v1',\n      timestampTolerance: 300\n    });\n\n    // Initialize HTTP client\n    this.http = new UniversalHttpClient(\n      {\n        baseUrl: this.config.apiUrl,\n        timeout: this.config.timeout,\n        maxRetries: this.config.maxRetries,\n        retryDelay: this.config.retryDelay\n      },\n      this.security\n    );\n\n    this.log('SDK initialized', { environment: Environment.info.platform });\n  }\n\n  /**\n   * Set authentication token for authenticated requests\n   */\n  setAuthToken(token: string | null): void {\n    this.security.setAuthToken(token);\n    this.log('Auth token updated', { hasToken: !!token });\n  }\n\n  /**\n   * Get current authentication token\n   */\n  getAuthToken(): string | undefined {\n    return this.security.getAuthToken();\n  }\n\n  /**\n   * Set cart token for session management\n   */\n  setCartToken(token: string | null): void {\n    this.security.setCartToken(token);\n    this.log('Cart token updated', { hasToken: !!token });\n  }\n\n  /**\n   * Get current cart token\n   */\n  getCartToken(): string | undefined {\n    return this.security.getCartToken();\n  }\n\n  /**\n   * Create singleton instance (recommended for most use cases)\n   */\n  static createInstance(config: StorefrontConfig): SecureStorefrontSDK {\n    const key = `${config.apiUrl}_${config.publicKey}`;\n    \n    if (!this.instances.has(key)) {\n      this.instances.set(key, new SecureStorefrontSDK(config));\n    }\n    \n    return this.instances.get(key)!;\n  }\n\n  /**\n   * Store API\n   */\n  get store() {\n    return {\n      get: async (params?: { include?: string[] }): Promise<Store> => {\n        const response = await this.http.get<ApiResponse<Store>>('/store', {\n          'X-Include': params?.include?.join(',') || ''\n        });\n        return response.data.data;\n      },\n\n      getCurrencies: async (): Promise<Array<{ code: string; symbol: string; name: string }>> => {\n        const response = await this.http.get<ApiResponse<any>>('/store/currencies');\n        return response.data.data;\n      },\n\n      changeCurrency: async (currency: string): Promise<void> => {\n        await this.http.post('/store/currency', { symbol: currency });\n      },\n\n      getSettings: async (): Promise<Record<string, any>> => {\n        const response = await this.http.get<ApiResponse<any>>('/store/settings');\n        return response.data.data;\n      },\n\n      getFeatures: async (): Promise<Array<{\n        id: number;\n        title: string;\n        description: string;\n        icon: string;\n        sort_order: number;\n      }>> => {\n        const response = await this.http.get<ApiResponse<any>>('/store/features');\n        return response.data.data;\n      },\n\n      getBanners: async (): Promise<Array<{\n        id: number;\n        title: string;\n        description: string;\n        image_url: string;\n        link_url: string;\n        sort_order: number;\n      }>> => {\n        const response = await this.http.get<ApiResponse<any>>('/store/banners');\n        return response.data.data;\n      }\n    };\n  }\n\n  /**\n   * Products API with Firebase/Supabase-style query builder\n   */\n  get products() {\n    return {\n      // Firebase/Supabase-style method chaining\n      where: (field: string, operator: '=' | '!=' | '>' | '<' | '>=' | '<=' | 'like', value: any) => ({\n        orderBy: (orderField: string, direction: 'asc' | 'desc' = 'asc') => ({\n          limit: (count: number) => ({\n            get: async (): Promise<Product[]> => {\n              const params = this.buildProductParams({ field, operator, value }, orderField, direction, count);\n              const response = await this.http.get<ApiResponse<Product[]>>('/products', params);\n              return response.data.data;\n            }\n          }),\n          get: async (): Promise<Product[]> => {\n            const params = this.buildProductParams({ field, operator, value }, orderField, direction);\n            const response = await this.http.get<ApiResponse<Product[]>>('/products', params);\n            return response.data.data;\n          }\n        }),\n        get: async (): Promise<Product[]> => {\n          const params = this.buildProductParams({ field, operator, value });\n          const response = await this.http.get<ApiResponse<Product[]>>('/products', params);\n          return response.data.data;\n        }\n      }),\n\n      // Direct methods\n      getAll: async (params?: { \n        page?: number; \n        per_page?: number; \n        search?: string; \n        category?: string;\n        sort?: string;\n      }): Promise<{ data: Product[]; pagination?: any }> => {\n        const response = await this.http.get<ApiResponse<Product[]>>('/products', params);\n        return {\n          data: response.data.data,\n          pagination: response.data.pagination\n        };\n      },\n\n      getById: async (id: number): Promise<Product> => {\n        const response = await this.http.get<ApiResponse<Product>>(`/products/${id}`);\n        return response.data.data;\n      },\n\n      getBySlug: async (slug: string): Promise<Product> => {\n        const response = await this.http.get<ApiResponse<Product>>(`/products/${slug}`);\n        return response.data.data;\n      },\n\n      search: async (query: string, options?: { \n        category?: string; \n        price_min?: number; \n        price_max?: number; \n        per_page?: number;\n      }): Promise<{ data: Product[]; pagination?: any }> => {\n        const response = await this.http.get<ApiResponse<Product[]>>('/products/search', {\n          q: query,\n          ...options\n        });\n        return {\n          data: response.data.data,\n          pagination: response.data.pagination\n        };\n      },\n\n      getFeatured: async (limit = 8): Promise<Product[]> => {\n        const response = await this.http.get<ApiResponse<Product[]>>('/featured-products', { limit });\n        return response.data.data;\n      },\n\n      getRelated: async (productId: number, limit = 4): Promise<Product[]> => {\n        const response = await this.http.get<ApiResponse<Product[]>>(`/products/${productId}/related`, { limit });\n        return response.data.data;\n      },\n\n      getReviews: async (productId: number, params?: { page?: number; per_page?: number }): Promise<{\n        data: Review[];\n        pagination?: any;\n      }> => {\n        const response = await this.http.get<ApiResponse<Review[]>>(`/products/${productId}/reviews`, params);\n        return {\n          data: response.data.data,\n          pagination: response.data.pagination\n        };\n      }\n    };\n  }\n\n  /**\n   * Categories API\n   */\n  get categories() {\n    return {\n      getAll: async (): Promise<Category[]> => {\n        const response = await this.http.get<ApiResponse<Category[]>>('/categories');\n        return response.data.data;\n      },\n\n      getById: async (id: number): Promise<Category> => {\n        const response = await this.http.get<ApiResponse<Category>>(`/categories/${id}`);\n        return response.data.data;\n      },\n\n      getBySlug: async (slug: string): Promise<Category> => {\n        const response = await this.http.get<ApiResponse<Category>>(`/categories/${slug}`);\n        return response.data.data;\n      },\n\n      getProducts: async (slug: string, params?: { \n        page?: number; \n        per_page?: number; \n        sort?: string;\n      }): Promise<{ data: Product[]; pagination?: any }> => {\n        const response = await this.http.get<ApiResponse<Product[]>>(`/categories/${slug}/products`, params);\n        return {\n          data: response.data.data,\n          pagination: response.data.pagination\n        };\n      }\n    };\n  }\n\n  /**\n   * Helper method to handle cart token from response\n   */\n  private handleCartResponse(responseData: any): any {\n    // Extract cart_token from response and store it\n    if (responseData.cart_token) {\n      this.setCartToken(responseData.cart_token);\n    }\n    return responseData;\n  }\n\n  /**\n   * Cart API\n   */\n  get cart() {\n    return {\n      get: async (): Promise<Cart> => {\n        const response = await this.http.get<ApiResponse<Cart>>('/cart');\n        return this.handleCartResponse(response.data.data);\n      },\n\n      addItem: async (productId: number, quantity = 1, options?: { \n        fields?: Record<string, any>;\n        notice?: string;\n      }): Promise<Cart> => {\n        const response = await this.http.post<ApiResponse<Cart>>('/cart/add', {\n          product_id: productId,\n          qty: quantity,\n          ...options\n        });\n        return this.handleCartResponse(response.data.data);\n      },\n\n      updateItem: async (itemId: string, quantity: number): Promise<Cart> => {\n        const response = await this.http.patch<ApiResponse<Cart>>(`/cart/items/${itemId}`, {\n          quantity\n        });\n        return this.handleCartResponse(response.data.data);\n      },\n\n      removeItem: async (itemId: string): Promise<Cart> => {\n        const response = await this.http.delete<ApiResponse<Cart>>(`/cart/items/${itemId}`);\n        return this.handleCartResponse(response.data.data);\n      },\n\n      clear: async (): Promise<void> => {\n        await this.http.delete('/cart/clear');\n        // Clear the stored cart token when cart is cleared\n        this.setCartToken(null);\n      },\n\n      getCount: async (): Promise<number> => {\n        const response = await this.http.get<ApiResponse<{ count: number; cart_token?: string }>>('/cart/count');\n        // Handle cart token from count response as well\n        if (response.data.data.cart_token) {\n          this.setCartToken(response.data.data.cart_token);\n        }\n        return response.data.data.count;\n      },\n\n      applyCoupon: async (code: string): Promise<Cart> => {\n        const response = await this.http.post<ApiResponse<Cart>>('/cart/coupon', { coupon: code });\n        return this.handleCartResponse(response.data.data);\n      },\n\n      removeCoupon: async (): Promise<Cart> => {\n        const response = await this.http.delete<ApiResponse<Cart>>('/cart/coupon');\n        return this.handleCartResponse(response.data.data);\n      }\n    };\n  }\n\n  /**\n   * Authentication API (client-side compatible)\n   */\n  get auth() {\n    return {\n      startPhoneAuth: async (phone: string, countryCode: string): Promise<{ session_token: string }> => {\n        const response = await this.http.post<ApiResponse<any>>('/auth/phone/start', {\n          phone,\n          country_code: countryCode\n        });\n        console.log('SecureSDK: startPhoneAuth full response:', response);\n        console.log('SecureSDK: response.data:', response.data);\n        console.log('SecureSDK: response.data.data:', response.data.data);\n        \n        // Laravel API returns: { success: true, data: { session_token: \"...\" }, message: \"...\" }\n        // We need to extract the session_token from response.data.data\n        const responseData = response.data as any;\n        \n        console.log('SecureSDK: responseData keys:', Object.keys(responseData));\n        console.log('SecureSDK: responseData.data:', responseData.data);\n        console.log('SecureSDK: responseData.data keys:', responseData.data ? Object.keys(responseData.data) : 'undefined');\n        \n        // Fix: Return the session_token directly from the Laravel response structure\n        if (responseData.data && responseData.data.session_token) {\n          console.log('SecureSDK: Found session_token:', responseData.data.session_token);\n          return { session_token: responseData.data.session_token };\n        } else {\n          console.error('SecureSDK: Could not find session_token in response');\n          return responseData;\n        }\n      },\n\n      verifyOTP: async (otp: string, sessionToken: string): Promise<{ \n        token: string; \n        customer: Customer;\n      }> => {\n        const requestBody = {\n          code: otp,\n          session_token: sessionToken\n        };\n        console.log('SecureSDK: verifyOTP request body:', requestBody);\n        const response = await this.http.post<ApiResponse<any>>('/auth/phone/verify', requestBody);\n        console.log('🔍 SecureSDK: Raw API response before sanitization:', JSON.stringify(response.data, null, 2));\n        console.log('🔍 SecureSDK: Extracted data (response.data.data):', JSON.stringify(response.data.data, null, 2));\n        return response.data.data;\n      },\n\n      resendOTP: async (sessionToken: string): Promise<void> => {\n        const requestBody = {\n          session_token: sessionToken\n        };\n        console.log('SecureSDK: resendOTP request body:', requestBody);\n        await this.http.post<ApiResponse<any>>('/auth/phone/resend', requestBody);\n      },\n\n      completeRegistration: async (data: {\n        firstName: string;\n        lastName: string;\n        email: string;\n        sessionToken: string;\n      }): Promise<{ token: string; customer: Customer }> => {\n        const response = await this.http.post<ApiResponse<any>>('/auth/complete', {\n          firstName: data.firstName,\n          lastName: data.lastName,\n          email: data.email,\n          session_token: data.sessionToken\n        });\n        return response.data.data;\n      },\n\n      getProfile: async (): Promise<Customer> => {\n        const response = await this.http.get<ApiResponse<Customer>>('/customer/profile');\n        return response.data.data;\n      },\n\n      updateProfile: async (data: Partial<Customer>): Promise<Customer> => {\n        const response = await this.http.patch<ApiResponse<Customer>>('/customer/profile', data);\n        return response.data.data;\n      },\n\n      logout: async (): Promise<void> => {\n        await this.http.post('/customer/logout');\n      }\n    };\n  }\n\n  /**\n   * Orders API (requires authentication)\n   */\n  get orders() {\n    return {\n      getAll: async (params?: { page?: number; per_page?: number }): Promise<{\n        data: Order[];\n        pagination?: any;\n      }> => {\n        const response = await this.http.get<ApiResponse<Order[]>>('/customer/orders', params);\n        return {\n          data: response.data.data,\n          pagination: response.data.pagination\n        };\n      },\n\n      getById: async (id: number): Promise<Order> => {\n        const response = await this.http.get<ApiResponse<Order>>(`/customer/orders/${id}`);\n        return response.data.data;\n      },\n\n      getCourses: async (): Promise<any[]> => {\n        const response = await this.http.get<ApiResponse<any[]>>('/customer/courses');\n        return response.data.data;\n      }\n    };\n  }\n\n  /**\n   * Checkout API\n   */\n  get checkout() {\n    return {\n      create: async (): Promise<{\n        type: 'free_order' | 'payment_required';\n        checkout_id?: string;\n        checkout_url?: string;\n        order_id?: number;\n        amount?: number;\n        redirect_url?: string;\n      }> => {\n        const response = await this.http.post<ApiResponse<any>>('/checkout');\n        return response.data.data;\n      },\n\n      getResult: async (sessionId: string): Promise<{ \n        status: string; \n        order?: Order;\n      }> => {\n        const response = await this.http.get<ApiResponse<any>>(`/checkout/${sessionId}/result`);\n        return response.data.data;\n      }\n    };\n  }\n\n  /**\n   * Wishlist API (requires authentication)\n   */\n  get wishlist() {\n    return {\n      get: async (): Promise<{ items: Product[]; count: number }> => {\n        const response = await this.http.get<ApiResponse<any>>('/wishlist');\n        return response.data.data;\n      },\n\n      addItem: async (productId: number): Promise<void> => {\n        await this.http.post('/wishlist', { product_id: productId });\n      },\n\n      removeItem: async (productId: number): Promise<void> => {\n        await this.http.delete(`/wishlist/${productId}`);\n      },\n\n      check: async (productId: number): Promise<{ in_wishlist: boolean }> => {\n        const response = await this.http.get<ApiResponse<any>>(`/wishlist/check/${productId}`);\n        return response.data.data;\n      },\n\n      clear: async (): Promise<void> => {\n        await this.http.delete('/wishlist/clear');\n      }\n    };\n  }\n\n  /**\n   * Reviews API\n   */\n  get reviews() {\n    return {\n      getAll: async (params?: { \n        page?: number; \n        per_page?: number; \n        rating?: number;\n      }): Promise<{ data: Review[]; pagination?: any }> => {\n        const response = await this.http.get<ApiResponse<Review[]>>('/reviews', params);\n        return {\n          data: response.data.data,\n          pagination: response.data.pagination\n        };\n      },\n\n      getRecent: async (limit = 6): Promise<Review[]> => {\n        const response = await this.http.get<ApiResponse<Review[]>>('/reviews/recent', { limit });\n        return response.data.data;\n      },\n\n      submit: async (productId: number, data: { \n        rating: number; \n        comment: string;\n      }): Promise<Review> => {\n        const response = await this.http.post<ApiResponse<Review>>(`/products/${productId}/reviews`, data);\n        return response.data.data;\n      },\n\n      getStats: async (): Promise<any> => {\n        const response = await this.http.get<ApiResponse<any>>('/reviews/stats');\n        return response.data.data;\n      }\n    };\n  }\n\n  /**\n   * Components API (for homepage content)\n   */\n  get components() {\n    return {\n      getAll: async (): Promise<any[]> => {\n        const response = await this.http.get<ApiResponse<any[]>>('/components');\n        return response.data.data;\n      }\n    };\n  }\n\n  /**\n   * Utility Methods\n   */\n\n  // Build query parameters for products\n  private buildProductParams(\n    where?: { field: string; operator: string; value: any },\n    orderField?: string,\n    direction?: string,\n    limit?: number\n  ): Record<string, any> {\n    const params: Record<string, any> = {};\n\n    if (where) {\n      if (where.field === 'featured' && where.operator === '=' && where.value) {\n        params.featured = true;\n      }\n      if (where.field === 'category' && where.operator === '=') {\n        params.category = where.value;\n      }\n      if (where.field === 'price' && where.operator === '>=') {\n        params.price_min = where.value;\n      }\n      if (where.field === 'price' && where.operator === '<=') {\n        params.price_max = where.value;\n      }\n    }\n\n    if (orderField && direction) {\n      params.sort = `${orderField}_${direction}`;\n    }\n\n    if (limit) {\n      params.per_page = limit;\n    }\n\n    return params;\n  }\n\n  // Logging utility\n  private log(message: string, data?: any): void {\n    if (this.config.enableLogging) {\n      console.log(`[StorefrontSDK] ${message}`, data || '');\n    }\n  }\n\n  /**\n   * Get SDK information\n   */\n  getInfo(): {\n    version: string;\n    environment: typeof Environment.info;\n    config: Omit<StorefrontConfig, 'secretKey'>;\n  } {\n    return {\n      version: this.config.version,\n      environment: Environment.info,\n      config: {\n        apiUrl: this.config.apiUrl,\n        publicKey: this.config.publicKey,\n        environment: this.config.environment,\n        timeout: this.config.timeout,\n        maxRetries: this.config.maxRetries,\n        enableLogging: this.config.enableLogging\n      }\n    };\n  }\n\n  /**\n   * Health check\n   */\n  async healthCheck(): Promise<{ status: 'ok' | 'error'; message?: string }> {\n    try {\n      await this.http.get('/health');\n      return { status: 'ok' };\n    } catch (error) {\n      return { \n        status: 'error', \n        message: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n}\n\n/**\n * Factory function for easy initialization\n */\nexport function createStorefrontSDK(config: StorefrontConfig): SecureStorefrontSDK {\n  return SecureStorefrontSDK.createInstance(config);\n}\n\n/**\n * Framework-specific helpers\n */\n\n// React Hook (if React is available)\nexport function useStorefrontSDK(config: StorefrontConfig) {\n  if (typeof globalThis !== 'undefined' && (globalThis as any).window && (globalThis as any).window.React) {\n    const React = (globalThis as any).window.React;\n    return React.useMemo(() => createStorefrontSDK(config), [\n      config.apiUrl, \n      config.publicKey, \n      config.environment\n    ]);\n  }\n  return createStorefrontSDK(config);\n}\n\n// Vue composable (if Vue is available)\nexport function useStorefront(config: StorefrontConfig) {\n  if (typeof globalThis !== 'undefined' && (globalThis as any).window && (globalThis as any).window.Vue) {\n    const Vue = (globalThis as any).window.Vue;\n    return Vue.computed(() => createStorefrontSDK(config));\n  }\n  return createStorefrontSDK(config);\n}\n\n// Export default for convenience\nexport default SecureStorefrontSDK;"],"mappings":"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","names":["Environment","isNode","isBrowser","isWebWorker","isServer","platform","key","__require","SecurityManager","config","token","Environment","timestamp","method","path","body","crypto","payload","hmac","signature","now","requestTime","expectedSignature","headers","error","input","bodyHash","data","key","a","b","result","i","item","sanitized","sensitiveFields","allowedTokens","value","keyLower","isAllowedToken","allowedToken","field","length","array","byte","response","UniversalHttpClient","config","security","request","url","body","authHeaders","headers","Environment","lastError","attempt","response","error","timeout","controller","timeoutId","fetchOptions","httpClient","axios","contentType","result","value","key","path","baseUrl","cleanPath","err","ms","resolve","params","requestUrl","searchParams","queryString","data","_SecureStorefrontSDK","config","SecurityManager","UniversalHttpClient","Environment","token","key","params","currency","field","operator","value","orderField","direction","count","response","id","slug","query","options","limit","productId","responseData","quantity","itemId","code","phone","countryCode","otp","sessionToken","requestBody","data","sessionId","where","message","error","SecureStorefrontSDK","createStorefrontSDK","useStorefrontSDK","useStorefront","secure_storefront_sdk_default"]}